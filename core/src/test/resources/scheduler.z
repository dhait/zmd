
\begin{zsection}
  \SECTION Stack \parents standard\_toolkit
\end{zsection}


\begin{zed}
  Stack[X] == [stack : \seq X]
\end{zed}

\begin{zed}
  InitStack[X] == [Stack[X] | stack = \emptyset]
\end{zed}

\begin{schema}{PushStack}[X]
  \Delta Stack[X]\\
  x? : X
\where
  stack' = stack \cat \langle x? \rangle
\end{schema}

\begin{schema}{PopStack}[X]
  \Delta Stack[X]\\
  x! : X
\where
  stack' \cat \langle x! \rangle = stack
\end{schema}

\begin{zsection}
  \SECTION Definitions \parents standard\_toolkit
\end{zsection}


\begin{zed}
  \relation (singleton~\_~)
\end{zed}

\begin{gendef}[X]
  singleton~\_ : \power (\power X)
\where
  \forall s : \power X @ singleton~s \iff \#s \leq 1
\end{gendef}


\begin{zed}
  WORD == 0 \upto 255
\end{zed}


\begin{axdef}
  mem\_size : WORD
\where
  mem\_size = 100
\end{axdef}



\begin{zed}
  [LABEL]
\end{zed}


\begin{zed}
  INST\_NAME ::= \\
    \t1 add | sub | divide | mult | push | pop |
      load | store | loadConst | print
\end{zed}
\begin{zed}
  OPERAND ::= AX | BX | CX | DX | constant \ldata WORD \rdata\\
\end{zed}
\begin{zed}
  REGISTER == \{ AX, BX, CX, DX \}\\
\end{zed}
\begin{zed}
  CONSTANT == OPERAND \setminus REGISTER
\end{zed}


\begin{schema}{Instruction}
  label : \power LABEL \\
  name : INST\_NAME \\
  params : \seq OPERAND
\where
  singleton~label
\end{schema}


\begin{zsection}
  \SECTION System \parents Definitions, Stack
\end{zsection}

\begin{zed}
  REGISTERS == REGISTER \fun OPERAND
\end{zed}
\begin{zed}
  MEMORY == 1 \upto mem\_size \pfun WORD
\end{zed}

\begin{schema}{System}
  registers : REGISTERS\\
  memory : MEMORY\\
  output : \seq WORD
\end{schema}

\begin{schema}{InitSystem}
  System
\where
  registers = \{ r : REGISTER @ r \mapsto constant(min(WORD)) \}\\
  memory = \{ m : 1 \upto mem\_size @ m \mapsto min(WORD) \}\\
  output = \langle \rangle
\end{schema}


\begin{zed}
  Arith\_Inst == [Instruction | \# params = 2 \land params(1) \in REGISTER]\\
  Add\_Inst == [Arith\_Inst| name = add]\\
  Sub\_Inst == [Arith\_Inst | name = sub]\\
  Mult\_Inst == [Arith\_Inst | name = mult]\\
  Div\_Inst == [Arith\_Inst | name = divide]
\end{zed}

\begin{zed}
  Memory\_Inst == [Instruction | \# params = 2 \land params(1) \in REGISTER \\
    \t1 \land params(2) \in CONSTANT]\\
  Load\_Inst == [Memory\_Inst | name = load]\\
  LoadConst\_Inst == [Memory\_Inst | name = loadConst]\\
  Store\_Inst == [Memory\_Inst | name = store]
\end{zed}

\begin{zed}
  Print\_Inst == [Instruction | \# params = 1]
\end{zed}

\begin{axdef}
  val : CONSTANT \fun WORD\\
  dereference : OPERAND \cross REGISTERS \fun WORD
\where
  \forall c : CONSTANT @ \\
    \t1 (\exists n : WORD @ c = constant(n) \land val(c) = n)\\
  \forall a : OPERAND ; r : REGISTERS @ \\
    \t1 dereference(a,r) = \\
      \t2 \IF a \in REGISTER \THEN dereference(r(a),r) \ELSE val(a)
\end{axdef}

\begin{schema}{Add}
  \Delta System\\
  Add\_Inst
\where
  \exists o_1 == dereference(params(1), registers);\\
    \t1 o_2 == dereference(params(2), registers) @\\
    \t1 registers' = registers \oplus
      \{ params(1) \mapsto constant(o_1 + o_2) \}\\
  memory' = memory\\
  output' = output
\end{schema}

\begin{schema}{Sub}
  \Delta System\\
  Sub\_Inst
\where
  \exists o_1 == dereference(params(1), registers);\\
    \t1 o_2 == dereference(params(2), registers) @\\
    \t1 registers' = registers \oplus
      \{ params(1) \mapsto constant(o_1 - o_2) \}\\
  memory' = memory\\
  output' = output
\end{schema}

\begin{schema}{Mult}
  \Delta System\\
  Mult\_Inst
\where
  \exists o_1 == dereference(params(1), registers);\\
    \t1 o_2 == dereference(params(2), registers) @\\
    \t1 registers' = registers \oplus
      \{ params(1) \mapsto constant(o_1 * o_2) \}\\
  memory' = memory\\
  output' = output
\end{schema}

\begin{schema}{Div}
  \Delta System\\
  Div\_Inst
\where
  \exists o_1 == dereference(params(1), registers);\\
    \t1 o_2 == dereference(params(2), registers) @\\
    \t1 registers' = registers \oplus
      \{ params(1) \mapsto constant(o_1 \div o_2) \}\\
  memory' = memory\\
  output' = output
\end{schema}

\begin{schema}{Load}
  \Delta System\\
  Load\_Inst
\where
  \exists o_2 == val(params(2)) @\\
    \t1 registers' = registers \oplus \\
      \t2 \{ params(1) \mapsto constant(memory(o_2)) \}\\
  memory' = memory\\
  output' = output
\end{schema}

\begin{schema}{Load\_Const}
  \Delta System\\
  LoadConst\_Inst
\where
  \exists o_2 == val(params(2)) @\\
    \t1 registers' = registers \oplus \{ params(1) \mapsto constant(o_2) \}\\
  memory' = memory\\
  output' = output
\end{schema}

\begin{schema}{Store}
  \Delta System\\
  Store\_Inst
\where
  \exists o_1 == dereference(params(1), registers);\\
    \t1 o_2 == val(params(2)) @\\
      \t2 memory' = memory \oplus \{ o_2 \mapsto o_1 \}\\
  registers' = registers\\
  output' = output
\end{schema}

\begin{schema}{Print}
  \Xi System\\
  Print\_Inst
\where
  output' = output \cat \langle dereference(params(1), registers) \rangle\\
  registers' = registers\\
  memory' = memory
\end{schema}

\begin{zed}
  Stack\_Inst == [Instruction | \#params = 1 ]\\
  Push\_Inst == [Stack\_Inst | name = push ]\\
  Pop\_Inst == [Stack\_Inst | name = pop]
\end{zed}

\begin{schema}{Push0}
  \Xi System\\
  PushStack[WORD]\\
  Push\_Inst
\where
  x? = dereference(params(1), registers)
\end{schema}

\begin{schema}{Pop0}
  \Delta System\\
  PopStack[WORD]\\
  Pop\_Inst
\where
  registers' = registers \oplus \{ params(1) \mapsto constant(x!) \}\\
  memory' = memory\\
  output' = output
\end{schema}

\begin{zed}
  Push == Push0 \project [ System ; Stack [WORD] ]\\
  Pop == Pop0 \project [System ; Stack [WORD] ]
\end{zed}

\begin{schema}{exec\_inst}
  \Delta System\\
  inst? : Instruction\\
  base? : 1 \upto mem\_size
\where
  \exists label : \power LABEL; name : INST\_NAME; params : \seq OPERAND |\\
    \t1 label = inst?.label \land name = inst?.name \land \\
    \t1 params = inst?.params @\\
      \t2 Add \lor Sub \lor Mult \lor Div \lor\\
      \t2 Print \lor Load\_Const \lor\\
      \t2 name \in \{load,store\} \implies (\exists p : \seq OPERAND |\\
        \t3 p = \langle params(1), \\
          \t4 constant(val(params(2))+base?) \rangle @\\
        \t3 Load [p/params] \lor Store [p/params] )
\end{schema}

\begin{zsection}
  \SECTION Scheduler \parents System
\end{zsection}

\begin{zed}
  Pid == \nat\\
  Priority == \negate 19 \upto 19\\
  Default\_Credits == 10
\end{zed}

\begin{zed}
  Status ::= pWaiting | pReady | pRunning
\end{zed}

\begin{schema}{Processes}
  pids : \power Pid\\
  status : Pid \pfun Status\\
  credits : Pid \pfun \nat\\
  priority : Pid \pfun Priority\\
  instructions : Pid \pfun (\seq Instruction)\\
  inst\_pointer : Pid \pfun \nat_1\\
  base, limit : Pid \pfun WORD\\
  pregisters : Pid \pfun REGISTERS\\
  pstack : Pid \pfun Stack[WORD]
\where
  pids = \dom(status) = \dom(credits) = \dom(priority) =\\
    \t1 \dom(instructions) = \dom(inst\_pointer) = \dom(base) =\\
    \t1 \dom(limit) = \dom(pstack)\\
  \forall pid : pids @ inst\_pointer(pid) \leq \#(instructions(pid))\\
  \forall pid : pids @ base(pid) + limit(pid) \leq mem\_size
\end{schema}

\begin{axdef}
  sort : (Pid \pfun \nat) \cross (Pid \pfun Priority) \pfun \iseq Pid
\where
  sort =
    (\lambda credits : (Pid \pfun \nat); priority :(Pid \pfun Priority) |\\
    \t2 \dom(credits) = \dom(priority) @\\
    \t2 (\mu s : \iseq Pid | \ran(s) = \dom(credits) \land\\
      \t3 (\forall i : 1 \upto \#s - 1 @\\
        \t4 credits(s(i)) > credits(s(i+1)) \lor\\
        \t4 (credits(s(i)) = credits(s(i+1)) \land\\
        \t4 \ priority(s(i)) > priority(s(i)))) @ s))
\end{axdef}

\begin{zed}
  Mode ::= user | kernel
\end{zed}

\begin{schema}{Scheduler}
  Processes\\
  System\\
  Stack[WORD]\\
  mode : Mode\\
  waiting, running : \power Pid\\
  ready : \iseq Pid
\where
  \# running \leq 1\\
  waiting \cap running \cap \ran ready = \emptyset\\
  waiting \cup running \cup \ran ready = pids\\
  waiting = \{ p : pids | (status \inv) (pWaiting) = p\}\\
  running = \{ p : pids | (status \inv) (pRunning) = p\}\\
  ready = sort((waiting \cup running) \ndres credits, \\
    \t1 (waiting \cup running) \ndres priority)\\
  \forall r : \ran(ready) @ status(r) = pReady\\
  \forall r : running @ credits(r) > 0
\end{schema}

\begin{schema}{InitScheduler}
    Scheduler\\
    InitStack[WORD]\\
    InitSystem
\where
    pids = \emptyset~; status = \emptyset~; priority = \emptyset\\
    credits = \emptyset~; instructions = \emptyset~; inst\_pointer = \emptyset\\
    waiting = \emptyset~; running = \emptyset~; ready = \langle \rangle\\
    base = \{\}~; limit = \{\}~; pregisters = \{\}\\
    mode = user
\end{schema}

\begin{schema}{create\_new\_process}
  \Delta Scheduler\\
  \Xi System\\
  priority? : Priority\\
  instructions? : \seq Instruction\\
  base?, limit? : WORD\\
  pid! : Pid
\where
  pid! \notin pids\\
  status' = status \cup \{ pid! \mapsto pReady \}\\
  credits' = credits \cup \{ pid! \mapsto Default\_Credits \}\\
  priority' = priority \cup \{ pid! \mapsto priority? \}\\
  instructions' = instructions \cup \{ pid! \mapsto instructions? \}\\
  inst\_pointer' = inst\_pointer \cup \{ pid! \mapsto 1 \}\\
  base' = base \cup \{ pid! \mapsto base? \}\\
  limit' = limit \cup \{ pid! \mapsto limit? \}\\
  pregisters' =\\
    \t1 pregisters \cup \{ pid! \mapsto \{ r : REGISTER @ \\
      \t2 r \mapsto constant(min(WORD)) \} \}\\
  pstack' =
    pstack \cup \{ pid! \mapsto (\lblot stack == \langle \rangle \rblot) \}\\
    pids' = pids \cup \{pid!\}
\end{schema}

\begin{zed}
  RescheduleChange == \\
    \t1 Scheduler \hide (status, running, ready, waiting, credits)
\end{zed}

\begin{schema}{reschedule}
  \Delta Scheduler\\
  \Xi RescheduleChange
\where
  ready \neq \emptyset\\
  \forall r : \ran(ready) @ credits(r) = 0 \implies\\
    \t1 credits' =
      \{ p : pids @ p \mapsto (credits(p) \div 2) + priority(p) \} \land\\
    \t1 status' = status\\
  \lnot (\forall r : \ran(ready) @ credits(r) = 0) \implies\\
    \t1 status' = status \oplus \{ head(ready) \mapsto pRunning \} \land\\
    \t1 credits' = credits
\end{schema}

\begin{zed}
  StatusChange == Scheduler \hide\\
    \t1 (status, running, waiting, ready, registers, pregisters, pstack)
\end{zed}

\begin{schema}{interrupt}
  \Delta Scheduler\\
  \Xi StatusChange\\
  create\_new\_process
\where
  mode = kernel\\
  running = \emptyset\lor(\exists p : running @ priority?\geq priority(p))\\
  \exists r : running @\\
    \t1 status'=status\oplus\{ pid!\mapsto pRunning, r\mapsto pReady \}\land\\
    \t1 pregisters' = pregisters \oplus \{ r \mapsto registers \} \land\\
    \t1 \theta Stack~' = pstack(r)\\
  registers' = pregisters(pid!)
\end{schema}

\begin{schema}{remove\_running\_process}
  \Delta Scheduler\\
  \Xi StatusChange
\where
  \exists pid == (\mu r : running) @\\
    \t1 status' = status \oplus \{ pid \mapsto pReady \} \land\\
    \t1 pregisters' = pregisters \oplus \{ pid \mapsto registers \} \land\\
    \t1 pstack' = pstack \oplus \{ pid \mapsto \theta Stack~' \}
\end{schema}

\begin{zed}
  block\_process == remove\_running\_process \semi reschedule
\end{zed}

\begin{zed}
  UnblockProcessChange == Scheduler \hide (status, running, ready, waiting)
\end{zed}

\begin{schema}{unblock\_process}
  \Delta Scheduler\\
  \Xi UnblockProcessChange\\
  pid? : Pid\\
\where
  pid? \in pids\\
  status(pid?) = pWaiting\\
  running=\emptyset \iff status'=status \oplus \{ pid? \mapsto pRunning \}\\
  running \neq \emptyset \iff status' = status \oplus \{ pid? \mapsto pReady \}
\end{schema}

\begin{schema}{remove\_process}
  \Delta Scheduler\\
  \Xi Stack[WORD]\\
  \Xi System\\
  pid? : Pid
\where
  pid? \in pids\\
  pids' = pids \setminus \{ pid? \}\\
  status' = \{ pid? \} \ndres status\\
  credits' = \{ pid? \} \ndres credits\\
  priority' = \{ pid? \} \ndres priority\\
  instructions' = \{ pid? \} \ndres instructions\\
  inst\_pointer' = \{ pid? \} \ndres inst\_pointer\\
  base'  = \{ pid? \} \ndres base\\
  limit'  = \{ pid? \} \ndres limit\\
  pregisters' = \{ pid? \} \ndres pregisters\\
  pstack' = \{ pid? \} \ndres pstack
\end{schema}

\begin{zed}
  ChangeInstPointer == Scheduler \hide (inst\_pointer)
\end{zed}

\begin{schema}{update\_process\_table}
  \Delta Scheduler\\
  inst! : Instruction\\
  base! : WORD
\where
  running \neq \emptyset\\
  (\exists pid == (\mu r : running) @\\
    \t1 inst! = head(instructions(pid)) \land\\
    \t1 base! = base(pid) \land\\
    \t1 (inst\_pointer(pid) = \#(instructions(pid)) \implies\\
      \t2 remove\_process[pid/pid?]) \land\\
    \t1 inst\_pointer(pid) < \#(instructions(pid)) \implies\\
      \t2 inst\_pointer' = \\
        \t3 inst\_pointer \oplus \{ pid \mapsto inst\_pointer(pid) + 1 \})\\
   \theta ChangeInstPointer = \theta ChangeInstPointer~'
\end{schema}

\begin{zed}
  next == exec\_inst \pipe update\_process\_table \semi{} \\
    \t2 ([\Delta Scheduler | running = \emptyset] \land reschedule) \lor\\
    \t2 ([\Xi Scheduler | running \neq \emptyset])
\end{zed}

\begin{zed}
  idle0 == \lnot \pre next
\end{zed}

\begin{schema}{idle}
  \Xi Scheduler\\
  inst? : Instruction\\
  base? : WORD
\where
  idle0
\end{schema}

\begin{zed}
  tick == next \lor idle
\end{zed}

\begin{zed}
  \vdash? (\forall n : \nat_1 @ n > 0)
\end{zed}
\begin{zed}
  [X] \vdash? \forall x : \power X @ \#x \leq 1 \iff singleton~x
\end{zed}

\begin{theorem}{PreconditionCheck}
   \vdash? \forall Scheduler @ \pre~update\_process\_table
\end{theorem}

